import { Request, Response } from 'express';
import { v4 as uuidv4 } from 'uuid';
import { PassService } from '../services/pass.service';
import { AppDataSource } from '../data-source';
import { PollingSession } from '../entities/PollingSession';
import { User } from '../entities/User';
import {
  generateRegistrationOptions,
  verifyRegistrationResponse,
} from '@simplewebauthn/server';
import { config } from '../config';
import { ethers } from 'ethers';

export class DeviceController {
  
  /**
   * Step 1: Generate WebAuthn Registration Options
   */
  static async generateRegistrationOptions(req: Request, res: Response) {
    try {
      // In a real flow, you might ask for a username or just generate one for a new wallet
      const username = `user-${uuidv4().slice(0, 8)}`;
      
      const userRepo = AppDataSource.getRepository(User);
      
      // Create a provisional user to store the challenge
      // In production, you might use a Redis cache for challenges to avoid DB writes for abandoned flows
      // But for MVP, we'll create the User entity.
      const newUser = userRepo.create({
        walletAddress: 'pending-' + uuidv4(), // Placeholder until address is calculated or we use this UUID
      });
      
      const options = await generateRegistrationOptions({
        rpName: config.security.rpName,
        rpID: config.security.rpId,
        userID: new Uint8Array(Buffer.from(newUser.id || uuidv4())), // Convert string to Uint8Array
        userName: username,
        // Don't exclude credentials for now as we are creating a new one
        attestationType: 'none',
        authenticatorSelection: {
          residentKey: 'preferred',
          userVerification: 'required', // Critical for Biometric Gate
          authenticatorAttachment: 'platform', // Force Platform authenticator (FaceID/TouchID)
        },
      });

      // Save challenge to user (we need to save the user first if it doesn't exist)
      // Since ID is generated by DB usually, let's save first.
      // Actually, we can just save the challenge in a temporary way or update the newUser object if we save it.
      newUser.currentChallenge = options.challenge;
      // We need to persist this user to retrieve challenge later.
      // But 'pending-...' address might conflict if we are not careful.
      await userRepo.save(newUser);

      // Return the ID we just created so frontend can send it back
      res.status(200).json({ options, tempUserId: newUser.id });
    } catch (error) {
      console.error('Error generating registration options:', error);
      res.status(500).json({ error: 'Internal server error' });
    }
  }

  /**
   * Step 2: Verify WebAuthn Registration Response
   */
  static async verifyRegistration(req: Request, res: Response) {
    try {
      const { tempUserId, response } = req.body;
      
      const userRepo = AppDataSource.getRepository(User);
      const user = await userRepo.findOneBy({ id: tempUserId });

      if (!user || !user.currentChallenge) {
        res.status(400).json({ error: 'User or challenge not found' });
        return;
      }

      const verification = await verifyRegistrationResponse({
        response,
        expectedChallenge: user.currentChallenge,
        expectedOrigin: config.security.origin,
        expectedRPID: config.security.rpId,
      });

      if (verification.verified && verification.registrationInfo) {
        const { credential } = verification.registrationInfo;
        const credentialID = credential.id;
        const credentialPublicKey = credential.publicKey;
        const counter = credential.counter;

        // 1. Update User with Credential Info
        user.credentialID = Buffer.from(credentialID).toString('base64');
        user.credentialPublicKey = Buffer.from(credentialPublicKey);
        user.counter = counter;
        user.isBiometricEnabled = true;
        user.currentChallenge = ''; // Clear challenge
        
        // 2. Calculate Deterministic Wallet Address (mock logic from before, but finalized)
        // In real app: create2 address based on public key or device ID
        // For now, we generate a stable mock address or use the one we derived
        const deviceLibraryId = uuidv4();
        const mockWalletAddress = `0x${deviceLibraryId.replace(/-/g, '').substring(0, 40)}`;
        
        user.walletAddress = mockWalletAddress;
        user.deviceLibraryId = deviceLibraryId;
        
        await userRepo.save(user);

        // 3. Create Session for Pass Generation (Legacy support for Onboarding flow)
        const sessionRepo = AppDataSource.getRepository(PollingSession);
        const sessionId = uuidv4();
        const newSession = sessionRepo.create({
            id: sessionId,
            status: 'completed',
            deviceId: deviceLibraryId,
            passUrl: `/api/device/pass/${deviceLibraryId}`
        });
        await sessionRepo.save(newSession);

        console.log(`[Device] WebAuthn Registration success. User: ${user.id}, Address: ${mockWalletAddress}`);

        res.status(200).json({ 
            verified: true, 
            sessionId,
            deviceLibraryId,
            walletAddress: mockWalletAddress 
        });
      } else {
        res.status(400).json({ verified: false, error: 'Verification failed' });
      }

    } catch (error) {
      console.error('Error verifying registration:', error);
      res.status(500).json({ error: 'Internal server error' });
    }
  }

  static async register(req: Request, res: Response) {
    // Legacy mock register - kept for fallback or testing if WebAuthn fails in dev
    // ... logic same as before ...
    try {
      const sessionRepo = AppDataSource.getRepository(PollingSession);
      const userRepo = AppDataSource.getRepository(User);
      
      // Start a new polling session
      const sessionId = uuidv4();
      const newSession = sessionRepo.create({
        id: sessionId,
        status: 'pending'
      });
      await sessionRepo.save(newSession);
      
      console.log(`[Device] Created session (LEGACY): ${sessionId}.`);
      
      const deviceLibraryId = uuidv4();
      
      setTimeout(async () => {
        try {
            const session = await sessionRepo.findOneBy({ id: sessionId });
            if (session) {
                session.status = 'completed';
                session.deviceId = deviceLibraryId;
                session.passUrl = `/api/device/pass/${deviceLibraryId}`;
                await sessionRepo.save(session);

                const mockWalletAddress = `0x${deviceLibraryId.replace(/-/g, '').substring(0, 40)}`;
                let user = await userRepo.findOneBy({ walletAddress: mockWalletAddress });
                if (!user) {
                    user = userRepo.create({
                        walletAddress: mockWalletAddress,
                        deviceLibraryId: deviceLibraryId,
                        isBiometricEnabled: true
                    });
                    await userRepo.save(user);
                }
            }
        } catch (err) {
            console.error(`[Device] Error updating session ${sessionId}:`, err);
        }
      }, 2000);

      res.status(200).json({ sessionId });
    } catch (error) {
      console.error('Error in register:', error);
      res.status(500).json({ error: 'Internal server error' });
    }
  }

  static async pollStatus(req: Request, res: Response) {
    try {
      const { sessionId } = req.params;
      const sessionRepo = AppDataSource.getRepository(PollingSession);
      const session = await sessionRepo.findOneBy({ id: sessionId });

      console.log(`[Device] Polling session: ${sessionId}. Found: ${!!session}`);

      if (!session) {
        res.status(404).json({ error: 'Session not found' });
        return;
      }

      res.status(200).json(session);
    } catch (error) {
      console.error('Error in pollStatus:', error);
      res.status(500).json({ error: 'Internal server error' });
    }
  }

  static async downloadPass(req: Request, res: Response) {
    try {
      const { deviceId } = req.params;
      
      // In real app, look up user by deviceId
      const mockUser = {
        address: '0x742d35Cc6634C0532925a3b844Bc454e4438f44e',
        balance: '1,250.50'
      };

      const passBuffer = await PassService.generatePass(mockUser);

      res.set('Content-Type', 'application/vnd.apple.pkpass');
      res.set('Content-Disposition', `attachment; filename=xvault-${deviceId}.pkpass`);
      res.send(passBuffer);
    } catch (error) {
      console.error('Error in downloadPass:', error);
      res.status(500).json({ error: 'Failed to generate pass' });
    }
  }

  static async verifyDevice(req: Request, res: Response) {
    try {
      const deviceId = req.headers['x-device-library-id'] as string;
      
      if (!deviceId) {
        res.status(403).json({ error: 'Device ID missing' });
        return;
      }

      // Verify against DB (mocked for now)
      // In production, check if deviceId exists in activeDevices table
      const isValid = true; // Assume valid for MVP demo

      if (!isValid) {
        res.status(403).json({ error: 'Invalid Device ID' });
        return;
      }

      res.status(200).json({ valid: true });
    } catch (error) {
      console.error('Error in verifyDevice:', error);
      res.status(500).json({ error: 'Internal server error' });
    }
  }
}
